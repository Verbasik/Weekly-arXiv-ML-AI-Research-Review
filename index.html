<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weekly Reviews</title>

    <!-- Настройки MathJax (без изменений) -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true,
                packages: {'[+]': ['ams', 'noerrors', 'physics', 'color', 'boldsymbol', 'mhchem']},
                macros: {
                    bm: ["\\boldsymbol{#1}", 1]
                }
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            svg: {
                fontCache: 'global',
                scale: 1.1
            },
            startup: {
                typeset: true
            }
        };
    </script>

    <!-- Используем полную версию MathJax (без изменений) -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>

    <!-- Используем стабильную версию marked (без изменений) -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>

    <style>
        /* --- Базовые стили (без изменений) --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
        }
        nav { margin-bottom: 20px; padding: 10px 0; border-bottom: 1px solid #e0e0e0; }
        nav a { margin-right: 15px; text-decoration: none; color: #007BFF; padding: 5px 10px; border-radius: 4px; }
        nav a:hover { background-color: #f0f0f0; text-decoration: underline; }
        nav a.active { background-color: #e6f2ff; font-weight: bold; }
        h1, h2, h3 { color: #333; margin-top: 1.5em; margin-bottom: 0.5em; }
        code { background-color: #f6f8fa; padding: 2px 5px; border-radius: 3px; font-family: Consolas, Monaco, monospace; }
        pre { background-color: #f6f8fa; padding: 15px; border-radius: 5px; overflow-x: auto; }
        img { display: block; max-width: 100%; height: auto; margin: 20px auto; }

        /* --- НАЧАЛО ОБНОВЛЕННЫХ СТИЛЕЙ MATHJAX --- */

        /* Стиль для блочных формул (теперь inline-block) */
        mjx-container[display="true"] {
            display: inline-block !important; /* Чтобы слушаться text-align родителя/обертки */
            margin-top: 0.5em !important;    /* Вертикальные отступы */
            margin-bottom: 0.5em !important;
            margin-left: 0 !important;       /* Убираем auto, центрирование через родителя/обертку */
            margin-right: 0 !important;
            text-align: initial !important;  /* Выравнивание текста ВНУТРИ формулы */
            max-width: 100%;                 /* Предотвратить выход за пределы */
            overflow-x: auto;                /* Прокрутка для широких формул */
            overflow-y: hidden;
            vertical-align: middle;          /* Выравнивание по вертикали */
        }

        /* Класс для родителя, содержащего ТОЛЬКО блочную формулу */
        .math-display-parent-center {
            text-align: center;
        }

        /* Класс для DIV-обертки, если в родителе есть и другой контент */
        .math-display-wrapper {
            text-align: center; /* Центрирует inline-block формулу внутри */
            margin-top: 1em;    /* Внешние отступы для обертки */
            margin-bottom: 1em;
            clear: both;        /* На случай обтекания */
        }

        /* Правильное отображение инлайновых формул (без изменений) */
        mjx-container:not([display="true"]) {
            display: inline !important;
            text-align: initial !important;
            margin: 0 !important;
            vertical-align: middle !important;
            padding: 0 0.2em;
        }

        /* Общие стили для контейнера MathJax (прокрутка, без изменений) */
        .mjx-container {
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* --- КОНЕЦ ОБНОВЛЕННЫХ СТИЛЕЙ MATHJAX --- */

        /* --- Стили для ошибок, изображений, UI (без изменений) --- */
        .math-error { color: #d9534f; background-color: #f9f2f2; padding: 8px; border-radius: 4px; margin: 10px 0; font-family: monospace; }
        .formula-error { background-color: #ffeeee; border-left: 3px solid #ff4444; padding: 10px; margin: 10px 0; font-family: monospace; white-space: pre-wrap; overflow-x: auto; }
        .highlight-error { background-color: #ffffd0; padding: 2px; border-bottom: 1px dashed red; }
        .image-container { text-align: center; margin: 20px 0; }
        .image-container img { max-width: 100%; margin: 0 auto; }
        .image-caption { font-style: italic; color: #666; margin-top: 8px; }
        #content { padding: 20px 0; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid #007BFF; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 20px auto; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .controls { margin: 20px 0; display: flex; gap: 10px; }
        button { background-color: #007BFF; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        .error-message { color: #d9534f; background-color: #f9f2f2; padding: 10px; border-radius: 4px; margin: 10px 0; display: none; }
        #source-view { margin-top: 30px; display: none; border: 1px solid #e0e0e0; border-radius: 5px; padding: 15px; }
    </style>
</head>
<body>
    <h1>Weekly Reviews</h1>

    <!-- Навигация (без изменений) -->
    <nav id="navigation">
        <a href="#" data-path="2025/week-01_&_02/review.md" class="nav-link">Week 01 & 02 Review</a>
        <a href="#" data-path="2025/week-03/review.md" class="nav-link">Week 03 Review</a>
        <a href="#" data-path="2025/week-04/review.md" class="nav-link">Week 04 Review</a>
        <a href="#" data-path="2025/week-05/review.md" class="nav-link">Week 05 Review</a>
        <a href="#" data-path="2025/week-06/review.md" class="nav-link">Week 06 Review</a>
        <a href="#" data-path="2025/week-07_&_08/review.md" class="nav-link">Week 07 & 08  Review</a>
        <a href="#" data-path="2025/week-09/review.md" class="nav-link">Week 09 Review</a>
        <a href="#" data-path="2025/week-10/review.md" class="nav-link">Week 10 Review</a>
        <a href="#" data-path="2025/week-11/review.md" class="nav-link">Week 11 Review</a>
        <a href="#" data-path="2025/week-12/review.md" class="nav-link">Week 12 Review</a>
        <a href="#" data-path="2025/week-13/review.md" class="nav-link">Week 13 Review</a>
    </nav>

    <!-- Элементы управления (без изменений) -->
    <div class="controls">
        <button id="reload-mathjax">Перезагрузить формулы</button>
        <button id="toggle-source">Показать/скрыть исходный текст</button>
    </div>

    <!-- Индикатор загрузки (без изменений) -->
    <div id="loader" class="loader"></div>

    <!-- Сообщение об ошибке (без изменений) -->
    <div id="error-message" class="error-message"></div>

    <!-- Контент (без изменений) -->
    <div id="content">
        <p>Выберите документ из списка выше.</p>
    </div>

    <!-- Контейнер для исходного текста (без изменений) -->
    <div id="source-view">
        <h3>Исходный Markdown</h3>
        <pre id="source-content"></pre>
    </div>

    <script>
        // Инициализация marked (без изменений)
        document.addEventListener('DOMContentLoaded', function() {
            marked.use({ mangle: false, headerIds: false, breaks: true });
        });

        // Хранилище для исходного текста (без изменений)
        let currentMarkdownText = '';
        let currentPath = '';

        // Функция для показа/скрытия исходного текста (без изменений)
        function toggleSourceView() {
            const sourceView = document.getElementById('source-view');
            if (sourceView.style.display === 'none' || sourceView.style.display === '') {
                sourceView.style.display = 'block';
                document.getElementById('source-content').textContent = currentMarkdownText;
            } else {
                sourceView.style.display = 'none';
            }
        }

        // --- НАЧАЛО ОБНОВЛЕННОГО JAVASCRIPT ---

        // Функция centerMathJaxFormulas() УДАЛЕНА

        // НОВАЯ функция для применения центрирования после рендеринга MathJax
        function applyDisplayMathCentering() {
            console.log("Applying display math centering..."); // Для отладки
            document.querySelectorAll('mjx-container[display="true"]').forEach(container => {
                let parent = container.parentElement;
                if (!parent) return;

                // --- Сброс предыдущих стилей/оберток (важно для reloadMathJax) ---
                // Удаляем класс центрирования с родителя, если он был
                parent.classList.remove('math-display-parent-center');

                // Проверяем, не является ли текущий родитель нашей оберткой
                if (parent.classList.contains('math-display-wrapper')) {
                     // Если да, то это обертка, которую мы создали ранее. Нужно ее убрать.
                     const grandParent = parent.parentElement;
                     if (grandParent) {
                         // Перемещаем формулу обратно к "дедушке" перед оберткой
                         grandParent.insertBefore(container, parent);
                         // Удаляем пустую обертку
                         grandParent.removeChild(parent);
                         // Теперь реальный родитель - это "дедушка"
                         parent = container.parentElement;
                         if (!parent) return; // На всякий случай
                     }
                }
                // --- Конец сброса ---

                // Проверяем, подходит ли родительский тег для применения стилей
                // (Расширенный список блочных элементов, где может быть формула)
                const suitableParentTags = ['P', 'DIV', 'LI', 'TD', 'TH', 'DD', 'DT', 'BLOCKQUOTE', 'BODY', 'ARTICLE', 'SECTION', 'ASIDE', 'MAIN', 'HEADER', 'FOOTER'];
                if (suitableParentTags.includes(parent.tagName)) {

                    // Проверяем, содержит ли родитель только формулу
                    // (игнорируя пустые текстовые узлы и комментарии)
                    const significantChildren = Array.from(parent.childNodes).filter(node =>
                        !( (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) || node.nodeType === Node.COMMENT_NODE )
                    );

                    if (significantChildren.length === 1 && significantChildren[0] === container) {
                        // Сценарий 1: Родитель содержит только формулу
                        // console.log("Applying class to parent:", parent); // Отладка
                        parent.classList.add('math-display-parent-center');
                    } else {
                        // Сценарий 2: Родитель содержит и другой контент
                        // Создаем обертку ТОЛЬКО если ее еще нет
                        if (!container.parentElement.classList.contains('math-display-wrapper')) {
                            // console.log("Creating wrapper for:", container); // Отладка
                            const wrapper = document.createElement('div');
                            wrapper.className = 'math-display-wrapper';
                            // Вставляем обертку перед формулой
                            parent.insertBefore(wrapper, container);
                            // Перемещаем формулу внутрь обертки
                            wrapper.appendChild(container);
                        }
                    }
                } else {
                     // console.log("Parent tag not suitable or not found:", parent ? parent.tagName : 'null'); // Отладка
                }
            });
             console.log("Centering applied."); // Отладка
        }

        // Функция для перезагрузки MathJax (обновлен вызов центрирования)
        function reloadMathJax() {
            try {
                if (typeof MathJax !== 'undefined') {
                    try {
                        if (typeof MathJax.texReset === 'function') MathJax.texReset();
                        if (typeof MathJax.typesetClear === 'function') MathJax.typesetClear();

                        if (typeof MathJax.typesetPromise === 'function') {
                            MathJax.typesetPromise()
                                .then(() => {
                                    showError('Формулы перезагружены успешно');
                                    checkAndFixFormulaErrors();
                                    applyDisplayMathCentering(); // <--- Вызов новой функции
                                })
                                .catch(err => {
                                    console.error('Ошибка при рендеринге формул:', err);
                                    showError('Проблема с рендерингом некоторых формул');
                                    // Попытка применить центрирование даже при ошибке рендеринга
                                    applyDisplayMathCentering();
                                });
                        } else if (typeof MathJax.Hub !== 'undefined') { // Fallback для v2
                            MathJax.Hub.Queue(
                                ["Typeset", MathJax.Hub],
                                [applyDisplayMathCentering] // <--- Вызов новой функции в очереди
                            );
                            showError('Формулы перезагружены (старый метод)');
                        } else { // Другие случаи
                             if (typeof MathJax.startup !== 'undefined' && typeof MathJax.startup.document !== 'undefined') {
                                MathJax.startup.document.clear();
                                MathJax.startup.document.updateDocument()
                                    .then(applyDisplayMathCentering) // <--- Вызов новой функции
                                    .catch(err => console.error("Error updating document", err));
                                showError('Формулы обновлены');
                            } else {
                                showError('Не удалось определить метод перезагрузки формул');
                            }
                        }
                    } catch (err) {
                        console.error('Ошибка MathJax API:', err);
                        showError('Возникла ошибка при обновлении формул');
                    }
                } else {
                    showError('MathJax не загружен. Попробуйте обновить страницу.');
                }
            } catch (error) {
                console.error('Ошибка при перезагрузке MathJax:', error);
                showError('Не удалось перезагрузить формулы');
            }
        }

        // Функция для отображения сообщений (без изменений)
        function showError(message) {
            const errorElement = document.getElementById('error-message');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            setTimeout(() => {
                errorElement.style.display = 'none';
            }, 3000);
        }

        // Функция для проверки и исправления ошибок формул (без изменений)
        function checkAndFixFormulaErrors() {
            document.querySelectorAll('.mjx-merror').forEach(errorElement => {
                const errorText = errorElement.textContent;
                const formulaElement = errorElement.closest('.mjx-container');
                if (formulaElement) {
                    const diagnosticElement = document.createElement('div');
                    diagnosticElement.className = 'formula-error';
                    diagnosticElement.textContent = 'Ошибка в формуле: ' + errorText;
                    const formulaText = formulaElement.getAttribute('data-formula') || '';
                    if (formulaText) {
                        diagnosticElement.textContent += '\nФормула: ' + formulaText;
                    }
                    formulaElement.after(diagnosticElement);
                }
            });
        }

        // Функции предобработки формул (checkBracketBalance, repairBracketBalance, fixSpecificFormulaIssues, preprocessFormula, preprocessMarkdown) - без изменений
        function checkBracketBalance(formula) { /* ... (код без изменений) ... */
             const brackets = { '\\left(': '\\right)', '\\left[': '\\right]', '\\left\\{': '\\right\\}', '\\left|': '\\right|', '\\left\\|': '\\right\\|', '\\left\\langle': '\\right\\rangle', '\\left\\lfloor': '\\right\\rfloor', '\\left\\lceil': '\\right\\rceil' };
             const leftCount = (formula.match(/\\left/g) || []).length;
             const rightCount = (formula.match(/\\right/g) || []).length;
             if (leftCount !== rightCount) { return { balanced: false, leftCount, rightCount, diff: leftCount - rightCount }; }
             return { balanced: true };
        }
        function repairBracketBalance(formula) { /* ... (код без изменений) ... */
            const result = checkBracketBalance(formula);
            if (result.balanced) { return formula; }
            let newFormula = formula;
            if (result.diff > 0) { newFormula += ' ' + '\\right.'.repeat(result.diff); }
            else if (result.diff < 0) { newFormula = '\\left. '.repeat(-result.diff) + newFormula; }
            return newFormula;
        }
        function fixSpecificFormulaIssues(formula) { /* ... (код без изменений) ... */
            let fixed = formula;
            if (formula.includes('J_{DAPO}(\\theta)')) { fixed = fixed.replace( /J_{DAPO}\(\\theta\) = \\mathbb{E}_{.*?}/g, 'J_{DAPO}(\\theta) = \\mathbb{E}_{(q,a) \\sim \\mathcal{D}, \\{o_i\\}_{i=1}^G \\sim \\pi_{\\theta,\\text{old}}(\\cdot|q)}' ); }
            fixed = fixed.replace(/\{\{([^{}]*)\}\}/g, '{$1}');
            fixed = fixed.replace(/\.\.\./g, '\\ldots');
            fixed = fixed.replace(/([^\\])_(\\[^{]|[a-zA-Z0-9])/g, '$1_{$2}');
            fixed = fixed.replace(/\\text\{s\.t\.\}(.*?)\|\{(.*?)\}\|/g, '\\text{s.t.}$1\\mid\\{$2\\}\\mid');
            if (fixed.includes('is\\_equivalent')) { fixed = fixed.replace(/\|\{o_i \| \\text\{is\\_equivalent\}(.*?)\}\|/g, '\\mid\\{o_i \\mid \\textrm{is\\_equivalent}$1\\}\\mid'); }
            fixed = fixed.replace(/\|\{([^{}|]*)\|([^{}|]*)\}\|/g, '\\mid\\{$1\\mid $2\\}\\mid');
            if (fixed.includes('\\text{s.t}') || fixed.includes('s.t.')) { fixed = fixed.replace(/\\text\{s\.t\.\}(.*?)0 < \|(.*?)\| < G/g, '\\text{s.t.}$1 0 < \\mid $2 \\mid < G'); }
            return fixed;
        }
        function preprocessFormula(formula) { /* ... (код без изменений) ... */
            let processed = formula .replace(/([^\\])_/g, '$1\\_') .replace(/\\mathbf{([^{}]+)}/g, '\\boldsymbol{$1}');
            processed = fixSpecificFormulaIssues(processed);
            processed = repairBracketBalance(processed);
            return processed;
        }
        function preprocessMarkdown(text) { /* ... (код без изменений) ... */
            const blockFormulas = []; const inlineFormulas = [];
            let processedText = text.replace(/(\$\$[\s\S]*?\$\$)/g, (match, p1) => { const id = blockFormulas.length; blockFormulas.push(p1); return `BLOCK_FORMULA_${id}`; });
            processedText = processedText.replace(/(\$[^\$\n]+\$)/g, (match, p1) => { const id = inlineFormulas.length; inlineFormulas.push(p1); return `INLINE_FORMULA_${id}`; });
            for (let i = 0; i < blockFormulas.length; i++) { let formulaContent = blockFormulas[i].slice(2, -2); formulaContent = preprocessFormula(formulaContent); blockFormulas[i] = `$$${formulaContent}$$`; }
            for (let i = 0; i < inlineFormulas.length; i++) { let formulaContent = inlineFormulas[i].slice(1, -1); formulaContent = preprocessFormula(formulaContent); inlineFormulas[i] = `$${formulaContent}$`; }
            for (let i = 0; i < blockFormulas.length; i++) { processedText = processedText.replace(`BLOCK_FORMULA_${i}`, blockFormulas[i]); }
            for (let i = 0; i < inlineFormulas.length; i++) { processedText = processedText.replace(`INLINE_FORMULA_${i}`, inlineFormulas[i]); }
            return processedText;
        }


        // Функция для загрузки Markdown (обновлен вызов центрирования)
        async function loadMarkdown(path) {
            try {
                document.getElementById('loader').style.display = 'block';
                const response = await fetch(path);
                if (!response.ok) throw new Error(`Ошибка загрузки: ${response.status}`);
                currentMarkdownText = await response.text();
                currentPath = path;
                const processedMarkdown = preprocessMarkdown(currentMarkdownText);
                window.location.hash = path;

                try {
                    const html = marked.parse(processedMarkdown);
                    document.getElementById('content').innerHTML = html;

                    // Обработка блоков кода с формулами (без изменений)
                    document.querySelectorAll('pre code').forEach(block => {
                        if (block.className.includes('language-math') || block.className.includes('language-tex')) {
                            const formula = block.textContent;
                            const wrapper = document.createElement('div');
                            wrapper.className = 'math-block'; // Возможно, этот класс тоже нужно стилизовать?
                            wrapper.innerHTML = `$$${formula}$$`;
                            block.parentNode.replaceWith(wrapper);
                        }
                    });

                    // Обработка изображений (без изменений)
                    processImages();

                    // Запускаем рендеринг MathJax и затем центрирование
                    // Небольшая задержка не нужна, т.к. typesetPromise ждет завершения
                    if (typeof MathJax !== 'undefined') {
                         if (typeof MathJax.typesetPromise === 'function') {
                            MathJax.typesetPromise(['#content']) // Указываем контейнер для ускорения
                                .then(() => {
                                    checkAndFixFormulaErrors();
                                    applyDisplayMathCentering(); // <--- Вызов новой функции
                                })
                                .catch(err => {
                                    console.error('Ошибка при рендеринге формул:', err);
                                    showError('Проблема с рендерингом некоторых формул');
                                    // Попытка применить центрирование даже при ошибке рендеринга
                                    applyDisplayMathCentering();
                                });
                        } else if (typeof MathJax.Hub !== 'undefined') { // Fallback для v2
                             MathJax.Hub.Queue(
                                ["Typeset", MathJax.Hub, "content"],
                                [applyDisplayMathCentering] // <--- Вызов новой функции в очереди
                            );
                        } else { // Другие случаи
                             if (typeof MathJax.startup !== 'undefined' && typeof MathJax.startup.document !== 'undefined') {
                                MathJax.startup.document.clear();
                                MathJax.startup.document.updateDocument()
                                    .then(applyDisplayMathCentering) // <--- Вызов новой функции
                                    .catch(err => console.error("Error updating document", err));
                            } else {
                                console.error('Не удалось найти метод рендеринга MathJax');
                            }
                        }
                    } else {
                         console.error('MathJax не загружен');
                    }

                } catch (renderError) {
                    console.error('Ошибка при рендеринге markdown:', renderError);
                    showError(`Ошибка рендеринга: ${renderError.message}`);
                    document.getElementById('content').innerHTML = `<pre>${processedMarkdown.replace(/</g, '<').replace(/>/g, '>')}</pre>`;
                }

            } catch (error) {
                console.error('Ошибка загрузки:', error);
                showError(`Ошибка: ${error.message}`);
            } finally {
                document.getElementById('loader').style.display = 'none';
            }
        }

        // Функция для обработки изображений (без изменений)
        function processImages() {
            document.querySelectorAll('#content img').forEach(img => {
                if (img.parentElement.classList.contains('image-container')) return;
                const container = document.createElement('div');
                container.className = 'image-container';
                const altText = img.getAttribute('alt') || '';
                const newImg = img.cloneNode(true);
                container.appendChild(newImg);
                if (altText && !altText.startsWith('http')) {
                    const caption = document.createElement('div');
                    caption.className = 'image-caption';
                    caption.textContent = altText;
                    container.appendChild(caption);
                }
                img.parentNode.replaceChild(container, img);
            });
        }

        // Инициализация страницы (без изменений)
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', function(event) {
                    event.preventDefault();
                    const path = this.getAttribute('data-path');
                    if (path) {
                        loadMarkdown(path);
                        document.querySelectorAll('.nav-link').forEach(l => l.classList.remove('active'));
                        this.classList.add('active');
                    }
                });
            });

            document.getElementById('reload-mathjax').addEventListener('click', reloadMathJax);
            document.getElementById('toggle-source').addEventListener('click', toggleSourceView);

            if (window.location.hash) {
                const path = window.location.hash.substring(1);
                // Небольшая задержка перед первой загрузкой, чтобы MathJax успел инициализироваться
                setTimeout(() => {
                     loadMarkdown(path);
                     const navLink = document.querySelector(`.nav-link[data-path="${path}"]`);
                     if (navLink) navLink.classList.add('active');
                }, 100); // Задержка в 100 мс
            } else {
                const firstLink = document.querySelector('.nav-link');
                if (firstLink) {
                     // Небольшая задержка перед первой загрузкой
                     setTimeout(() => { firstLink.click(); }, 100);
                }
            }
        });

        // --- КОНЕЦ ОБНОВЛЕННОГО JAVASCRIPT ---
    </script>
</body>
</html>