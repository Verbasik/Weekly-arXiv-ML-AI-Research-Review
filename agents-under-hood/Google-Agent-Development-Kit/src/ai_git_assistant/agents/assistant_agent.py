# -*- coding: utf-8 -*-

"""
Модуль определяет инструменты (tools) для взаимодействия с Git и
создает агента-помощника.

Этот модуль содержит функции для выполнения основных Git-операций, таких как
получение различий в файлах, создание коммитов и отправка изменений
на удаленный сервер. Он также определяет и создает экземпляр
`GitAssistantAgent`, который использует эти инструменты для своей работы.
"""

# Стандартные библиотеки
import os
import subprocess
from typing import Tuple

# Сторонние библиотеки
from google.adk.agents import Agent


def get_git_diff(repo_path: str) -> Tuple[bool, str]:
    """
    Description:
    ---------------
        Добавляет все изменения в области подготовки (staging area) и
        возвращает результат выполнения `git diff --staged`.

    Args:
    ---------------
        repo_path (str): Абсолютный путь к локальному Git-репозиторию.

    Returns:
    ---------------
        Tuple[bool, str]: Кортеж, где первый элемент — это флаг успеха
        (True/False), а второй — либо содержимое diff, либо
        сообщение об ошибке.

    Raises:
    ---------------
        subprocess.CalledProcessError: Возникает, если команда Git
        завершается с ошибкой.
        FileNotFoundError: Возникает, если команда `git` не найдена в системе.

    Examples:
    ---------------
        >>> success, output = get_git_diff('/path/to/my/repo')
        >>> if success:
        ...     print(output)
        ... else:
        ...     print(f"Error: {output}")
    """
    try:
        # Шаг 1: Добавить все измененные и новые файлы в staging area.
        # Это эквивалентно выполнению `git add .` в терминале.
        subprocess.run(
            ["git", "add", "."],
            cwd=repo_path,        # Указываем рабочий каталог для команды
            check=True,           # Проверяем, что команда завершилась успешно
            capture_output=True,  # Захватываем вывод команды
            text=True             # Декодируем вывод в текстовый формат
        )

        # Шаг 2: Получить diff для файлов, находящихся в staging area.
        # Это необходимо, чтобы агент получил точную информацию об изменениях.
        diff_result = subprocess.run(
            ["git", "diff", "--staged"],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True
        )
        # Возвращаем успешный результат и сам diff
        return True, diff_result.stdout

    except subprocess.CalledProcessError as e:
        # Обработка ошибок, если любая из команд git завершилась неудачно.
        error_message = f"Произошла ошибка при выполнении git: {e.stderr}"
        return False, error_message

    except FileNotFoundError:
        # Обработка случая, когда git не установлен или не найден в PATH.
        error_message = (
            "Ошибка: команда 'git' не найдена. "
            "Убедитесь, что Git установлен и доступен в системном PATH."
        )
        return False, error_message


def create_commit(repo_path: str, message: str) -> Tuple[bool, str]:
    """
    Description:
    ---------------
        Создает Git-коммит с предоставленным сообщением.

    Args:
    ---------------
        repo_path (str): Абсолютный путь к локальному Git-репозиторию.
        message (str): Сообщение для коммита.

    Returns:
    ---------------
        Tuple[bool, str]: Кортеж с флагом успеха и статусным сообщением.

    Raises:
    ---------------
        subprocess.CalledProcessError: Если команда `git commit` завершается
        с ошибкой.

    Examples:
    ---------------
        >>> success, status = create_commit(
        ...     '/path/to/repo',
        ...     'feat: add new feature'
        ... )
        >>> print(status)
        'Коммит успешно создан.'
    """
    try:
        # Выполняем команду `git commit` с переданным сообщением.
        subprocess.run(
            ["git", "commit", "-m", message],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True
        )
        return True, "Коммит успешно создан."

    except subprocess.CalledProcessError as e:
        # Обработка ошибок, возникших в процессе создания коммита.
        error_message = f"Произошла ошибка во время коммита: {e.stderr}"
        return False, error_message


def push_to_remote(repo_path: str) -> Tuple[bool, str]:
    """
    Description:
    ---------------
        Отправляет коммиты на удаленный репозиторий (git push).

    Args:
    ---------------
        repo_path (str): Абсолютный путь к локальному Git-репозиторию.

    Returns:
    ---------------
        Tuple[bool, str]: Кортеж с флагом успеха и статусным сообщением.

    Raises:
    ---------------
        subprocess.CalledProcessError: Если команда `git push` завершается
        с ошибкой (например, из-за конфликтов или проблем с доступом).

    Examples:
    ---------------
        >>> success, status = push_to_remote('/path/to/repo')
        >>> print(status)
        'Изменения успешно отправлены на удаленный сервер.'
    """
    try:
        # Выполняем команду `git push` для отправки изменений.
        subprocess.run(
            ["git", "push"],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True
        )
        return True, "Изменения успешно отправлены на удаленный сервер."

    except subprocess.CalledProcessError as e:
        # Обработка ошибок, возникших при отправке.
        error_message = f"Произошла ошибка во время push: {e.stderr}"
        return False, error_message


def create_git_assistant_agent() -> Agent:
    """
    Description:
    ---------------
        Создает и настраивает экземпляр агента `GitAssistantAgent`.

    Returns:
    ---------------
        Agent: Настроенный экземпляр агента.

    Examples:
    ---------------
        >>> assistant = create_git_assistant_agent()
        >>> print(assistant.name)
        'GitAssistant'
    """
    # Это основная инструкция (промпт), которая определяет поведение
    # и роль AI-агента. Она четко указывает, что агент должен делать
    # (анализировать diff), в каком формате должен быть результат
    # (Conventional Commits) и чего делать не следует (добавлять лишний текст).
    instruction = (
    """
    <role>
    Вы — высокоточный AI-аналитик кода, специализирующийся на написании сообщений для git-коммитов в строгом соответствии со спецификацией Conventional Commits v1.0.0.
    </role>

    <goal>
    Ваша задача — проанализировать предоставленный `git diff` и сгенерировать одно единственное, идеально отформатированное сообщение для коммита.
    </goal>

    <context>
    ### Спецификация Conventional Commits

    Структура сообщения должна быть следующей:
    `<type>[optional scope]: <description>`
    `[optional body]`
    `[optional footer]`

    **Допустимые типы (`<type>`):**
    - **feat:** Новая функциональность.
    - **fix:** Исправление ошибки.
    - **docs:** Изменения в документации.
    - **style:** Изменения, не влияющие на логику кода (форматирование, пропущенные точки с запятой и т.д.).
    - **refactor:** Рефакторинг кода без изменения его внешнего поведения.
    - **perf:** Улучшение производительности.
    - **test:** Добавление или исправление тестов.
    - **chore:** Прочие изменения, не затрагивающие исходный код или тесты (обновление зависимостей, настройка сборки и т.п.).

    **Критические изменения (BREAKING CHANGE):**
    - Могут быть частью любого типа.
    - Обозначаются добавлением `!` после типа/скоупа (например, `feat(api)!:`) и обязательным наличием футера `BREAKING CHANGE: <описание>`.
    </context>

    <thinking_process>
    1.  **Анализ сути:** внимательно изучи `git diff`. Какова основная цель этих изменений? Это добавление нового, исправление старого, или техническая реорганизация?
    2.  **Определение типа:** на основе анализа выбери наиболее подходящий `<type>` из списка выше.
    3.  **Определение скоупа (scope):** постарайся определить затронутый компонент, модуль или часть системы (например, `api`, `auth`, `ui-kit`). Если изменение затрагивает множество компонентов, оставь `scope` пустым.
    4.  **Написание описания (description):** сформулируй краткое (до 50 символов) описание в настоящем времени, отражающее суть коммита. Например, "добавляет эндпоинт для..." вместо "добавлен эндпоинт".
    5.  **Проверка на BREAKING CHANGE:** если изменения нарушают обратную совместимость, добавь `!` и футер `BREAKING CHANGE:`.
    6.  **Формирование тела (body):** если описание слишком короткое для объяснения контекста ("почему" и "как"), добавь развернутое описание в `body`.
    7.  **Финальная сборка:** собери сообщение в соответствии со спецификацией.
    </thinking_process>

    <examples>
    **Пример 1: Простое исправление**
    *   **Diff:**
        ```diff
        - return x * x;
        + return x + x;
        ```
    *   **Результат:**
        ```
        fix: исправляет ошибку в вычислении квадрата числа
        ```

    **Пример 2: Новая функция со скоупом**
    *   **Diff:**
        ```diff
        + function login(user, pass) { ... }
        ```
    *   **Результат:**
        ```
        feat(auth): добавляет функцию аутентификации пользователя
        ```

    **Пример 3: Рефакторинг с телом сообщения**
    *   **Diff:** (Большой diff с переименованием переменных и вынесением логики в отдельную функцию)
    *   **Результат:**
        ```
        refactor(parser): выносит логику парсинга токенов в отдельный сервис

        Логика обработки токенов была разбросана по нескольким методам,
        что затрудняло поддержку. Теперь она инкапсулирована в TokenParsingService
        для улучшения читаемости и тестируемости.
        ```

    **Пример 4: Критическое изменение (BREAKING CHANGE)**
    *   **Diff:**
        ```diff
        - function getUser(id) { ... }
        + function getUser(id, options) { ... }
        ```
    *   **Результат:**
        ```
        feat(api)!: изменяет сигнатуру метода getUser

        BREAKING CHANGE: Метод getUser теперь требует второй аргумент `options`.
        Старые вызовы `getUser(id)` больше не будут работать.
        ```
    </examples>

    <instruction>
    Проанализируй `git diff`, который предоставит пользователь.
    Твой ответ должен содержать ИСКЛЮЧИТЕЛЬНО сгенерированное сообщение коммита в виде развернутого текста, строго на Русском языке. \`\`\`.

    Коммит должен обладать следующими критериям:
    - Он должен быть написан на русском языке.
    - Коммит должен обладать критерием информационной полноты, для этого он должен быть написан в формате развернутого текста.
    - Коммит должен обладать критерием информационной значимости, что бы изучая историю коммитов, можно было восстановить весь исторический контекст.
    </instruction>
    """
    )

    # Модель можно переопределить через переменную окружения GEMINI_MODEL.
    # Значение по умолчанию использует стабильный общедоступный идентификатор модели.
    model_id = os.getenv("GEMINI_MODEL", "gemini-2.5-flash-lite")

    return Agent(
        name="GitAssistant",
        model=model_id,
        instruction=instruction,
        description="AI-ассистент для автоматизации Git-операций.",
        # Передаем агенту список функций, которые он может использовать.
        tools=[get_git_diff, create_commit, push_to_remote]
    )
